\documentclass{../../slides-style}

\slidetitle{Динамическое выделение памяти}{14.02.2026}

\usepackage{xurl}

\begin{document}

    \begin{frame}[plain]
        \titlepage
    \end{frame}

    \section{Аллокаторы}

    \begin{frame}{Аллокаторы}
        \begin{outline}
            \1 С аллокаторами памяти все уже работали
            \1 Они нужны, чтобы работать со структурами данных динамического размера
            \1 Аллокатор работает с кучей (heap)
            \1 Для аллокатора куча --- множество блоков разного размера
            \1 Блок --- непрерывный кусок виртуальной памяти, который может быть либо выделенным (allocated), либо свободным (free)
            \1 Не уменьшая общности, предполагаем, что куча растет по увеличению количества адресов
        \end{outline}
    \end{frame}

    \begin{frame}{Какие бывают аллокаторы}
        \begin{outline}
            \1 Явные (Explicit)
                \2 Программа явно освобождает выделенный блок
                \2 malloc и free в С, new и delete в C++\dots
            \1 Неявные (Implicit)
                \2 Аллокатор сам берет на себя обнаружение и освобождение неиспользованных блоков
                \2 Сборщики в мусора в Java, .NET, Lisp\dots
            \2 В этом курсе мы будем говорить о явных
        \end{outline}
    \end{frame}

    \begin{frame}{Напомним}
        \begin{outline}
            \1 \mintinline{c}{void* malloc(size_t size)} --- выделяет блок памяти размера не менее size
                \2 Возвращает указатель на выделенный блок или NULL в случае ошибки
                \2 Блок памяти обычно выравнивается (В Unix-системах --- по 8 байт)
                \2 Не занимается инициализацией! Для этого есть calloc
                \2 В рамках лекции считаем размер слова равным 4 байта
            \1 \mintinline{c}{void free(*ptr)} --- освобождает блок памяти, на который указывает ptr
                \2 ptr должен указывать на начало выделенного блока --- иначе \emph{UB}
                    \3 Кроме \texttt{NULL} --- с ним он просто ничего не делает
                \2 free не сигнализирует об ошибке --- с ним надо быть аккуратнее
        \end{outline}
    \end{frame}

    \begin{frame}[fragile]{Как аллокатор может выделять память?}
        \begin{outline}
            \1 \texttt{mmap} и \texttt{munmap}
                \2 Отображение объекта в физической памяти в адресное пространство процесса
                \2 \texttt{/proc/[pid]/maps} --- показать отображенные участки памяти процесса
            \1 Управление размером кучи: \texttt{void* sbrk(intptr\_t incr)}
                \2 \texttt{brk} --- указатель на конец кучи
                \2 \texttt{sbrk} просто прибавляет \texttt{incr} к этому указателю
                \2 Надо, чтобы запросить у ОС больше памяти в куче
        \end{outline}
    \end{frame}

    \begin{frame}{Требования к аллокатору}
        \begin{outline}
            \1 Последовательность запросов \texttt{malloc} и \texttt{free} --- произвольная
                \2 Нельзя полагаться на порядок запросов
                \2 Но мы предполагаем, что \texttt{free} вызывается на участке, который был выделен
            \1 Немедленный ответ на запрос
                \2 Нельзя буферизировать запросы или переупорядочивать
            \1 Используется только куча
                \2 Все нескалярные структуры данных, которыми пользуется аллокатор, должны лежать в куче
            \1 Выравнивание блоков
                \2 Нужно, чтобы в блоке могли размещаться данные любого типа
                \2 В большинстве систем выравнивается по 8 байт
            \1 Нельзя модифицировать выделенные блоки
                \2 Можно манипулировать только свободными блоками
        \end{outline}
    \end{frame}

    \begin{frame}{Цели аллокатора}
        \begin{outline}
            \1 Максимизация пропускной способности (throughput)
                \2 Количество запросов, выполняющихся в единицу времени
                \2 Нужно уменьшать среднее время на запрос к аллокатору
            \1 Максимальная утилизация памяти (memory utilization)
                \2 Полезная нагрузка (payload) --- сколько памяти действительно было запрошено
                \2 Нам нужно максимизировать суммированную полезную нагрузку для всех запросов относительно размера кучи
            \1 Эти цели противоречат друг другу
        \end{outline}
    \end{frame}

    \begin{frame}{Фрагментация}
        \begin{outline}
            \1 Фрагментация --- главная причина плохой утилизации кучи
            \1 Неиспользованная память не соответствует требованиям запросов аллокатора
            \1 Внутренняя фрагментация
                \2 Выделили больше, чем было запрошено (больше, чем payload)
                \2 Минимальный размер блока
                \2 Выравнивание
            \1 Внешняя фрагментация
                \2 В куче есть место, чтобы выделить память, но нет доступных свободных блоков
                \2 Зависит в том числе от будущих запросов
        \end{outline}
    \end{frame}

    \begin{frame}[fragile]{Нюансы реализации}
        Мы могли бы сделать простой аллокатор:
        \begin{outline}
            \1 Куча --- массив с указателем p на начало
            \1 \mintinline{c}{malloc(size)}: увеличить указатель p на size, вернуть новый указатель
            \1 \mintinline{c}{free(ptr)}: просто return, ничего не делать
        \end{outline}

        Что мы получили:
        \begin{outline}
            \1 Хорошая пропускная способность, все запросы за константу
            \1 Отвратительная утилизация памяти --- не переиспользуем свободные блоки
        \end{outline}
    \end{frame}

    \begin{frame}{Нюансы реализации}
        Если мы хотим добиться баланса между целями, нужно ответить на следующие вопросы:

        \begin{outline}
            \1 \textbf{Free block organization} --- как отслеживать свободные блоки?
            \1 \textbf{Placement} --- как выбрать свободный блок, куда мы будем аллоцировать?
            \1 \textbf{Splitting} --- как только заняли свободный блок, что делать с оставшейся частью?
            \1 \textbf{Coalescing} --- что делать с только что освобожденным блоком?
        \end{outline}
    \end{frame}

    \begin{frame}{Implicit Free List}
        \begin{outline}
            \1 Как различать границы блоков и понимать, свободен блок или нет? \\
            \1 Будем хранить все нужное в самом блоке:
        \end{outline}

        \begin{center}
            \includegraphics[width=0.8\linewidth]{implicit-free-list.png}
        \end{center}
    \end{frame}

    \begin{frame}{Как выглядит куча? (Free block organization)}
        \begin{center}
            \includegraphics[width=0.9\linewidth]{free-block-organization.png}
        \end{center}

        \begin{outline}
            \1 Последовательность занятых и свободных блоков
                \2 Односвязный список свободных блоков
            \1 Время на операцию --- линейное от количества \textbf{всех} блоков
                \2 Это недостаток, с которым в будущем будем бороться
            \1 Выравнивание
                \2 Появляется минимальный размер блока --- 2 слова
        \end{outline}
    \end{frame}

    \begin{frame}{Размещение выделенного блока (placement)}
        При запросе аллокации --- поиск подходящего свободного блока.

        А как искать? Есть разные \textbf{политики размещения}!

        \begin{outline}
            \1 first fit --- берем первый попавшийся подходящего размера
                \2 Обычно свободные блоки побольше оказываются в конце списка
                \2 В начале свободные блоки меньше => поиск блока побольше займет больше времени
            \1 next fit --- начинаем поиск там, где закончился предыдущий
                \2 Есть вероятность, что следующий подходящий блок --- остаток предыдущего
                \2 Может работать быстрее, чем first fit
                \2 Хуже утилизирует память
            \1 best fit --- перебираем все блоки и ищем подходящий с наименьшим размером
                \2 Лучше утилизирует память
                \2 Хуже по времени --- бежим по всей куче
        \end{outline}
    \end{frame}

    \begin{frame}{Разделение свободных блоков (splitting)}
        Нашли подходящий свободный блок --- сколько надо занять?
        \begin{outline}
            \1 Можем весь блок --- плохо, внутренняя фрагментация
            \1 Можем делить на две части --- выделенный блок и остаток
        \end{outline}
    
        На примере --- запрос на 3 слова:
    
        \begin{center}
            \includegraphics[width=0.9\linewidth]{splitting.png}
        \end{center}
    \end{frame}

    \begin{frame}{Получение дополнительной памяти в куче}
        Что, если так и не нашли подходящий свободный блок?

        \begin{outline}
            \1 Объединение свободных блоков (об этом дальше)
            \1 Если не сработало --- просим у ОС больше памяти через \texttt{sbrk}
            \1 Превращаем новый кусок памяти в большой свободный блок
            \1 Вставляем блок в список и используем его для выделения
        \end{outline}
    \end{frame}

    \begin{frame}{Объединение свободных блоков (coalescing)}
        При освобождении свободные блоки могут оказаться рядом:

        \begin{center}
            \includegraphics[width=0.9\linewidth]{coalescing.png}
        \end{center}

        \begin{outline}
            \1 Получили \emph{ложную фрагментацию}:
                \2 Запрос на 4 слова не выполнится, хотя место есть
                \2 У нас два блока с payload = 3 слова
            \1 Блоки надо объединять
        \end{outline}
    \end{frame}

    \begin{frame}{Нюансы объединения}
        Когда это можно делать?

        \begin{outline}
            \1 Сразу при запросе
                \2 Быстро
                \2 Может привести к лишним действиям
            \1 Когда-то позже
                \2 Если не нашли свободный блок, например
                \2 Требует отдельного прохода по куче
        \end{outline}
    \end{frame}

    \begin{frame}{Нюансы объединения}
        Допустим, освободили текущий блок
        \begin{outline}
            \1 Объединиться со следующим --- легко за константное время
            \1 А как объединяться с предыдущим?
            \1 С текущей реализацией --- только за линейное время от количества
                \2 Получаем довольно медленный free
            \1 Как добиться константы?
            \1 Нам поможет Дональд Кнут!
        \end{outline}
    \end{frame}

    \begin{frame}{Метод граничных маркеров}
        Улучшим наш блок:

        \begin{center}
            \includegraphics[width=0.75\linewidth]{border-marker.png}
        \end{center}

        Теперь можем получить размер предыдущего блока!
    \end{frame}

    \begin{frame}{Метод граничных маркеров --- случаи}
        \begin{center}
            \includegraphics[width=0.75\linewidth]{border-marker-cases.png}
        \end{center}
    \end{frame}

    \begin{frame}{Метод граничных маркеров}
        \begin{outline}
            \1 Получили константное время в каждом случае
            \1 Подход легко обобщить на разные типы аллокаторов
            \1 Тратим много памяти на header и footer
            \1 Можем оптимизировать:
                \2 Можем избавиться от футера у выделенных блоков
        \end{outline}
    \end{frame}

    \begin{frame}{Implicit Free Lists --- что получили?}
        \begin{outline}
            \1 Линейное время от количества всех блоков на аллокацию
            \1 Константное время на освобождение
            \1 Очень просто реализовать
            \1 Редко используется из-за скорости malloc, но при этом в определенных случаях может подойти
            \1 Разделение и объединение может распространяться почти на все аллокаторы!
        \end{outline}
    \end{frame}

    \begin{frame}{Explicit Free List}
        Строим \textbf{двусвязный список} из свободных блоков!

        \begin{center}
            \includegraphics[width=0.75\linewidth]{explicit-free-list-block.png}
            \includegraphics[width=0.75\linewidth]{explicit-free-list.png}
        \end{center}
    \end{frame}

    \begin{frame}{Explicit Free List --- аллокация блока}
        \begin{outline}
            \1 Так же, как в Implicit Free List
            \1 Опять же, политики размещения бывают разные!
        \end{outline}
    \end{frame}

    \begin{frame}{Explicit Free List --- освобождение блока}
        \begin{outline}
            \1 Зависит от \textbf{политики вставки в список}
                \2 Last In First Out (LIFO) --- вставляем новый блок в начало
                    \3 free работает за константу
                \2 Address order --- блоки в списке упорядочены по адресам
                    \3 free работает за линию --- проходим по списку
                    \3 мы лучше утилизируем память: проход first fit приближается к best fit!
            \1 Граничные маркеры все еще нужны для объединения блоков
        \end{outline}
    \end{frame}

    \begin{frame}{Explicit Free List --- что получили?}
        \begin{outline}
            \1 По сравнению с Implicit Free List:
                \2 Улучшили время аллокации: линейное время от количества свободных блоков, а не от количества всех блоков
                \2 Нужно больше места на свободный блок, ведь мы храним указатели
                \2 Это может увеличивать внутреннюю фрагментацию!
            \1 Время на аллокацию можно еще улучшить!
        \end{outline}
    \end{frame}

    \begin{frame}{Segregated Free Lists}
        \begin{outline}
            \1 Массив списков со свободными блоками определенных размеров
            \1 Множество блоков разбиваем на классы по размерам
            \1 Политик того, как разбить блоки на классы --- много
                \2 Можно по степеням двойки
                \2 Можно маленькие размеры выделять в отдельные классы
        \end{outline}
        \begin{center}
            \includegraphics[width=0.6\linewidth]{segregated-free-lists.png}
        \end{center}
    \end{frame}

    \begin{frame}{Segregated Free Lists --- аллокация и освобождение}
        \begin{outline}
            \1 Аллокация блока размера n:
                \2 Ищем в списке свободных блоков подходящего класса
                \2 Если нашли свободный блок --- выделяем
                    \3 Разделить, а остаток поместить в нужный список --- опционально
                \2 Если не нашли, пробуем искать в списке блоков большего размера
            \1 Перебрали все списки и не нашли --- что делать?
                \2 Просим больше памяти у ОС при помощи \texttt{sbrk()}
                \2 Выделяем из новой памяти блок нужного размера
                \2 Остаток выделяем в отдельный блок и вставляем в нужный список
            \1 Освобождение блока:
                \2 Вставка блока в нужный список
                \2 Можем объединять блоки со вставкой в нужный список --- опционально
        \end{outline}
    \end{frame}

    \begin{frame}{Segregated Free Lists --- что мы уже получили?}
        \begin{outline}
            \1 Время на запрос стало ниже
            \1 Теперь исследуем не всю кучу, а какую-то часть
            \1 Лучше используем память
            \1 Проход с политикой first fit приближает best fit
        \end{outline}

        То, что мы сейчас описали --- концепция. Рассмотрим более конкретные реализации.
    \end{frame}

    \begin{frame}{Simple Segregated Storage}
        \begin{outline}
            \1 Каждый список хранит блоки одного размера
                \2 Пример: размеры 17-32 --- округляем до 32
            \1 Выделение блока:
                \2 Смотрим нужный список. Если не пуст --- берем первый блок. Не разделяем
                \2 Список пуст --- запрашиваем у ОС кусок памяти, и делим его на блоки нужного размера, теперь список не пуст
            \1 Освобождение:
                \2 Вставляем новый свободный блок в начало нужного списка
                \2 Никакого объединения
        \end{outline}
    \end{frame}

    \begin{frame}{Simple Segregated Storage --- что получили?}
        \begin{outline}
            \1 \texttt{malloc} и \texttt{free} за \emph{константное время}
            \1 Уменьшили минимальный размер блока
                \2 Нам нужен только указатель на следующий блок
            \1 Страдаем от внутренней фрагментации
                \2 Не разделяем же блоки
            \1 Страдаем от внешней фрагментации
                \2 Есть конкретные сценарии
                \2 Много запросов на размер 1, много запросов на размер 2 …
        \end{outline}
    \end{frame}

    \begin{frame}{Segregated Fits}
        \begin{outline}
            \1 Каждый список --- явный или неявный (как описывалось ранее)
                \2 В списке --- блоки разных размеров!
            \1 Выделение блока:
                \2 Бежим по нужному списку по политике first fit
                \2 Нашли --- делим, остаток отправляем в нужный список
                \2 Не нашли --- ищем в списке класса больших размеров
                \2 Перебрали все списки? Просим памяти у ОС, выделяем нужный блок, остаток --- помещаем в нужный список
            \1 Освобождение блока:
                \2 Объединяем блоки и результат отправляем в нужный список
        \end{outline}
    \end{frame}

    \begin{frame}{Segregated Fits --- что получили?}
        \begin{outline}
            \1 Поиск не по всей куче, а по ее части
            \1 first fit здесь приближается к best fit по всей куче
            \1 Популярный подход
                \1 Используется в пакете malloc стандартной библиотеки Си
        \end{outline}
    \end{frame}

    \begin{frame}{Двоичные близнецы}
        \begin{outline}
            \1 Segregated Fits, только каждый класс --- степень двойки
                \2 Округляем размеры
            \1 Пусть в куче $2^m$ слов
            \1 Держим список для блоков размеров $2^k$, $0 \leq k \leq m$
            \1 Изначально у нас один блок размером $2^m$
        \end{outline}
    \end{frame}

    \begin{frame}{Двоичные близнецы --- выделение блока}
        \begin{outline}
            \1 Допустим, хотим выделить блок размером $2^k$
            \1 Надо найти первый доступный блок размером $2^j$, $k \leq j \leq m$
            \1 Рекурсивно:
                \2 Если $j = k$ --- закончили
                \2 Если нет --- рекурсивно делим блок пополам, пока $j$ не станет равным $k$
                \2 При делении оставшуюся часть (близнеца) отправляем в нужный список
            \1 Пример --- минимальный размер блока --- 64 К, запросили 34 К
        \end{outline}

        \begin{center}
            \includegraphics[width=1\linewidth]{binary-twins.png}
        \end{center}
    \end{frame}

    \begin{frame}{Двоичные близнецы --- освобождение блока}
        \begin{outline}
            \1 Объединяем блоки, пока не дойдем до близнеца
            \1 Пример: освобождаем блок D
        \end{outline}

        \begin{center}
            \includegraphics[width=1\linewidth]{binary-twins-deallocation.png}
        \end{center}
    \end{frame}

    \begin{frame}{Двоичные близнецы --- что получили?}
        \begin{outline}
            \1 Быстрый поиск и объединение
                \2 Знаем адрес и размер блока --- легко посчитать адрес близнеца
                \2 xxx…x00000 --- адрес блока размером 32 байта
                \2 xxx…x10000 --- адрес близнеца
                \2 Отличие в одном бите!
            \1 Страдаем от внутренней фрагментации
            \1 Может подойти, когда размеры выделенных блоков известны и они близки к степеням двойки
        \end{outline}
    \end{frame}

    \begin{frame}{Итог}
        \begin{outline}
            \1 Разных аллокаторов много --- и они нужны:
                \2 Разным вариантам ОС
                \2 СУБД
                \2 Реализациям языков программирования
                \2 Разным программам на Си
            \1 Здесь рассмотрена только малая часть, их гораздо больше
        \end{outline}
    \end{frame}

    \begin{frame}{Благодарности}

        Рассказ про виртуальную память основан на материалах Я.А.~Кириленко

        Рассказ про аллокаторы~--- перевёрстан в \LaTeX{} из презентации В.А.~Кутуева

    \end{frame}

\end{document}
